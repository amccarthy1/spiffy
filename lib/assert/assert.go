package assert

import (
	"bufio"
	"bytes"
	"fmt"
	"reflect"
	"runtime"
	"strings"
	"testing"
	"unicode"
	"unicode/utf8"
)

type assert struct {
	t *testing.T
}

func New(t *testing.T) assert {
	return assert{t: t}
}

func isEmpty(object interface{}) bool {
	if object == nil {
		return true
	} else if object == "" {
		return true
	}

	objValue := reflect.ValueOf(object)

	switch objValue.Kind() {
	case reflect.Map:
		fallthrough
	case reflect.Slice, reflect.Chan:
		{
			return (objValue.Len() == 0)
		}
	}
	return false
}

func areEqual(expected, actual interface{}) bool {
	if expected == nil && actual == nil {
		return true
	}
	if (expected == nil && actual != nil) || (expected != nil && actual == nil) {
		return false
	}
	return reflect.DeepEqual(expected, actual)
}

func (a assert) NotNil(object interface{}) bool {
	if object == nil {
		fail(a.t, "Should not be nil")
		return false
	}
	return true
}

func (a assert) NotNilFatal(object interface{}) {
	if object == nil {
		failNow(a.t, "Should not be nil")
	}
}

func (a assert) Nil(object interface{}) bool {
	if object != nil {
		failf(a.t, "Should be nil: %v", object)
		return false
	}
	return true
}

func (a assert) NilFatal(object interface{}) {
	if object != nil {
		failNowf(a.t, "Should be nil: %v", object)
	}
}

func (a assert) Empty(object interface{}) bool {
	if !isEmpty(object) {
		fail(a.t, "Collection is empty")
		return false
	}
	return true
}

func (a assert) EmptyFatal(object interface{}) {
	if !isEmpty(object) {
		failNow(a.t, "Collection is empty")
	}
}

func (a assert) NotEmpty(object interface{}) bool {
	if isEmpty(object) {
		fail(a.t, "Collection is not empty")
		return false
	}
	return true
}

func (a assert) NotEmptyFatal(object interface{}) {
	if isEmpty(object) {
		failNow(a.t, "Collection is not empty")
	}
}

func (a assert) Equal(expected interface{}, actual interface{}) bool {
	if !areEqual(expected, actual) {
		failf(a.t, "Objects are equal\n\t%v\n\t!=\n\t%v", expected, actual)
		return false
	}
	return true
}

func (a assert) EqualFatal(expected interface{}, actual interface{}) {
	if !areEqual(expected, actual) {
		failNowf(a.t, "Objects are equal\n\t%v\n\t!=\n\t%v", expected, actual)
	}
}

func (a assert) NotEqual(expected interface{}, actual interface{}) bool {
	if areEqual(expected, actual) {
		failf(a.t, "Objects are not equal\n\t%v\n\t==\n\t%v", expected, actual)
		return false
	}
	return true
}

func (a assert) NotEqualFatal(expected interface{}, actual interface{}) {
	if areEqual(expected, actual) {
		failNowf(a.t, "Objects are not equal\n\t%v\n\t==\n\t%v", expected, actual)
	}
}

func (a assert) True(object bool) bool {
	if !object {
		fail(a.t, "Expects true")
		return false
	}
	return true
}

func (a assert) TrueFatal(object bool) {
	if !object {
		failNow(a.t, "Expects true")
	}
}

func (a assert) False(object bool) bool {
	if object {
		fail(a.t, "Expects false")
		return false
	}
	return true
}

func (a assert) FalseFatal(object bool) {
	if object {
		failNow(a.t, "Expects false")
	}
}

func failNowf(t *testing.T, format string, args ...interface{}) {
	failNow(t, fmt.Sprintf(format, args...))
}

func failNow(t *testing.T, message string) {
	fail(t, message)
	t.FailNow()
}

func failf(t *testing.T, format string, args ...interface{}) {
	fail(t, fmt.Sprintf(format, args...))
}

func fail(t *testing.T, message string) {
	errorTrace := strings.Join(callerInfo(), "\n\r\t\t\t")
	t.Errorf("\r%s\r\tAssert Location:\t%s\n"+
		"\r\tAssertion:%s\n",
		getWhitespaceString(),
		errorTrace,
		indentMessageLines(message, 2),
	)
}

//dirty. lifted straight from testify/assert
func callerInfo() []string {

	pc := uintptr(0)
	file := ""
	line := 0
	ok := false
	name := ""

	callers := []string{}
	for i := 0; ; i++ {
		pc, file, line, ok = runtime.Caller(i)
		if !ok {
			return nil
		}

		// This is a huge edge case, but it will panic if this is the case, see #180
		if file == "<autogenerated>" {
			break
		}

		parts := strings.Split(file, "/")
		dir := parts[len(parts)-2]
		file = parts[len(parts)-1]
		if dir != "assert" && dir != "mock" && dir != "require" {
			callers = append(callers, fmt.Sprintf("%s:%d", file, line))
		}

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}
		name = f.Name()
		// Drop the package
		segments := strings.Split(name, ".")
		name = segments[len(segments)-1]
		if isTest(name, "Test") ||
			isTest(name, "Benchmark") ||
			isTest(name, "Example") {
			break
		}
	}

	return callers
}

func isTest(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) { // "Test" is ok
		return true
	}
	rune, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(rune)
}

func getWhitespaceString() string {

	_, file, line, ok := runtime.Caller(1)
	if !ok {
		return ""
	}
	parts := strings.Split(file, "/")
	file = parts[len(parts)-1]

	return strings.Repeat(" ", len(fmt.Sprintf("%s:%d:      ", file, line)))

}

func indentMessageLines(message string, tabs int) string {
	outBuf := new(bytes.Buffer)

	for i, scanner := 0, bufio.NewScanner(strings.NewReader(message)); scanner.Scan(); i++ {
		if i != 0 {
			outBuf.WriteRune('\n')
		}
		for ii := 0; ii < tabs; ii++ {
			outBuf.WriteRune('\t')
			// Bizarrely, all lines except the first need one fewer tabs prepended, so deliberately advance the counter
			// by 1 prematurely.
			if ii == 0 && i > 0 {
				ii++
			}
		}
		outBuf.WriteString(scanner.Text())
	}

	return outBuf.String()
}
